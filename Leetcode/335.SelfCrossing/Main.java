import java.util.*;
/**
 * 2016-4-28
 * 此题非常妙! 不会做,抄自http://www.voidcn.com/blog/zdavb/article/p-5749387.html
 * 
 * 解释:[引自:http://www.voidcn.com/blog/zdavb/article/p-5749387.html]
 * -------------------------------------------------------------------------------
 * 这道题网友给出了一些做法，但无外都是说将所有相交的轨迹都可以抽象为三种模型，但是并没有给出为什么，
 * 以及是怎么样抽象出来的。 
 * 我在看代码的过程中才明白是什么意思，所有的你能想到的乱七八糟、五花八门的轨迹，在相交的那个瞬间，
 * 其实你可以通过旋转你的轨迹，将它变成网友所说的那三种。 
 * 也即：
 *
 * 两条线的交点在第i条线和第i-5条线上（说第0条和第5条的完全是误导）
 * 两条线的交点在第i条和第i-4条线上（两条线连接成一条线）
 * 两条线的交点在第i条和第i-3条线上
 *
 * 再想想还会有其他情况吗？首先，i肯定不能和自己的临边相交，所以肯定不会出现i-1的情况，i-2呢？i-2与i处于平行线关系,
 * 所以是不可能的。当然了，i-6也是平行线也不可以，那么i-7、i-8或者i-9呢？答案是不可能的。 因为轨迹走动是有方向的，
 * 即逆时针方向，而i-5与i-7平行，且i-5的位置一定高于i-7（如果把i-7作为底部看），而此时i的走向是向下的，
 * 如果i要与I-7相交，那么必须先于I-5相交。同理,i-8、i-9也都是不可能出现的。 
 * --------------------------------------------------------------------------------
 * 确实:画几个图,可以把走势分为:内卷,外旋和重叠.
 * 内卷
 *    ┌───┐            ________
 *    │   │            | ____ |
 *    └───┼──>         | |  | |
 *        │            |____| |
 * 外旋
 *    ┌──────┐              
 *    │      │
 *    │
 *    │
 *    └────────────>
 * 重叠
 *    ┌───┐           
 *    │   |            
 *    └───|        
 *         
 * 内卷对应i,i-3相交;外旋对应i,i-5相交;重叠对应i,i-4相交.
 * 如文中分析的,i不能和i-1,i-2相交,可以和i-3,i-4,i-5相交,i-6平行所以不相交,
 * i-7等等之后的不是平行,就是:如果要相交则必然首先和i-3 or i-5相交.
 * 
 * 这题的思考方式以前没接触过,完全没有头绪,我的想法就是内卷外旋重叠三种情况,但是并没有看出其可以转化为i,i-3;i,i-5;i,i-4;这样.
 * 现在也想不出来是怎么想到的,感觉没掌握精髓.
 * 代码居然就这么几行!非常值得学习!   
 */
public class Main{
    public boolean isSelfCrossing(int[] x) {
        int length = x.length;
        for(int i = 3;i<length;i++){
            if(i >= 3 && x[i]>=x[i-2] && x[i-1] <= x[i-3])
                return true;
            if(i >= 4 && x[i]+x[i-4] == x[i-2] && x[i-1] == x[i-3])
                return true;
            if(i >= 5 && x[i]+x[i-4] >= x[i-2] && x[i-1] + x[i-5] >= x[i-3] && x[i-4]<=x[i-2] && x[i-1] <= x[i-3])
                return true;
        }
        return false;
    }
    public static void main(String args[]){
        //int[] nums = {2,2,2,1,1};
        //int[] nums = {2,1,1,2};
        //int[] nums = {2,2,3,4,1,3};
        //int[] nums = {1,1,2,1,1};
        int[] nums = {3,3,3,2,1,1};
        System.out.println(new Main().isSelfCrossing(nums));
    }    
}